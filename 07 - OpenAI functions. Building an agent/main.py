import os
import openai
import requests
import sqlite3
from tenacity import retry, wait_random_exponential, stop_after_attempt
from dotenv import load_dotenv

# Load environment variables
load_dotenv()
openai.api_key = os.getenv("OPENAI_API_KEY")

# Constants
MODEL = "gpt-4o"
DATABASE = "db/games.sqlite"
USER_MESSAGE = "What are the top 5 teams that developed games with the highest average ratings, grouped by genre, where each genre has at least 5 games?"

# Retry logic for API requests
@retry(wait=wait_random_exponential(min=1, max=40), stop=stop_after_attempt(3))
def chat_completion_request(messages, functions=None, model=MODEL):
    headers = {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + openai.api_key,
    }
    json_data = {"model": model, "messages": messages}
    if functions is not None:
        json_data.update({"functions": functions})
    try:
        response = requests.post(
            "https://api.openai.com/v1/chat/completions",
            headers=headers,
            json=json_data,
        )
        return response
    except Exception as e:
        print("Unable to generate ChatCompletion response")
        print(f"Exception: {e}")
        return e

# Function to execute SQL queries
def ask_database(conn, query):
    try:
        results = conn.execute(query).fetchall()
        return results
    except Exception as e:
        raise Exception(f"SQL error: {e}")

# Function to handle ChatCompletion with function execution
def chat_completion_with_function_execution(messages, functions=None):
    try:
        response = chat_completion_request(messages, functions)
        full_message = response.json()["choices"][0]
        if full_message.get("finish_reason") == "function_call":
            print("Function generation requested, calling function")
            return call_function(messages, full_message)
        else:
            print("Function not required, responding to user")
            return response.json()
    except Exception as e:
        print("Unable to generate ChatCompletion response")
        print(f"Exception: {e}")
        return response

# Function to handle function calls generated by the model
def call_function(messages, full_message):
    if full_message["message"]["function_call"]["name"] == "ask_database":
        query = eval(full_message["message"]["function_call"]["arguments"])
        print(f"Executing query: {query}")
        try:
            results = ask_database(conn, query["query"])
        except Exception as e:
            print(e)
            messages.append({
                "role": "system",
                "content": f"Error in query: {e}. Please generate a corrected SQL query."
            })
            response = chat_completion_request(messages, model=MODEL)
            return response.json()

        messages.append({"role": "function", "name": "ask_database", "content": str(results)})
        response = chat_completion_request(messages)
        return response.json()
    else:
        raise Exception("Function does not exist and cannot be called")

# Database schema string
schema_string = """
Table: games
Columns: â„– (Primary Key), Title, Release Date, Team, Rating, Times Listed, Number of Reviews, Genres, Summary, Reviews, Plays, Playing, Backlogs, Wishlist
"""

functions = [
    {
        "name": "ask_database",
        "description": "Use this function to answer user questions about data. Output should be a fully formed SQL query.",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": f"""
                            SQL query extracting info to answer the user's question.
                            SQL should be written using this database schema:
                            {schema_string}
                            The query should be returned in plain text.
                            """,
                }
            },
            "required": ["query"],
        },
    }
]

if __name__ == "__main__":
    # Connect to the SQLite database
    conn = sqlite3.connect(DATABASE)

    # Initialize messages and interaction
    system_message = "You are DatabaseGPT, an assistant who gets answers to user questions from the database."
    messages = [
        {"role": "system", "content": system_message},
        {"role": "user", "content": USER_MESSAGE},
    ]

    # Handle user interaction
    chat_response = chat_completion_with_function_execution(messages, functions=functions)

    try:
        assistant_message = chat_response["choices"][0]["message"]["content"]
        print("Assistant response:", assistant_message)
    except Exception as e:
        print("Error in generating response:", e)

    # Close the database connection
    conn.close()
